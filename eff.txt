-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package eff
@version 0.0.0.0

module Control.Effect.Internal

-- | The kind of effect handlers, which are monad transformers.
type HandlerK = (Type -> Type) -> Type -> Type

-- | The kind of effects, which are classes of monads.
type EffectK = (Type -> Type) -> Constraint

-- | A monad transformer for handling effects. <tt>(<a>EffT</a> t)</tt> is
--   actually no different from <tt>t</tt> at runtime, but it provides a
--   different set of instances. Wrapping a monad transformer with
--   <a>EffT</a> allows other effects to be automatically lifted through
--   it, provided the underlying transformer provides a
--   <a>MonadTransControl</a> instance.
--   
--   <a>EffT</a> cannot be used with any arbitrary monad transformer: all
--   monad transformers wrapped with <a>EffT</a> <i>must</i> provide an
--   instance of the <a>Handles</a> type family to cooperate with effect
--   with the effect lifting machinery. However, note that this requirement
--   only applies to transformers wrapped in <a>EffT</a> directly, i.e.
--   used as the <tt>t</tt> argument in <tt>(<a>EffT</a> t)</tt>; there are
--   no restrictions placed on the underlying monad (though effects will
--   not be able to be automatically lifted through non-<a>EffT</a>
--   layers).
newtype EffT (t :: HandlerK) m a
EffT :: t m a -> EffT (t :: HandlerK) m a
[runEffT] :: EffT (t :: HandlerK) m a -> t m a

-- | A type alias for a stack of nested <a>EffT</a> transformers:
--   <tt><a>EffsT</a> '[t1, t2, ..., tn] m</tt> is equivalent to
--   <tt><a>EffT</a> t1 (<a>EffT</a> t2 (... (<a>EffT</a> tn m) ...))</tt>.
--   
--   This can be considered the implementation dual to the <a>Can</a>
--   interface.
type family EffsT ts m

-- | An <b>internal</b> helper class used to work around GHC’s inability to
--   handle quantified constraints over type families. The constraint
--   <tt>(forall m. c m =&gt; <a>OverEffs</a> c ts m)</tt> is morally
--   equivalent to <tt>(forall m. c m =&gt; c (EffsT ts m))</tt>, but the
--   latter is not allowed by GHC. The cost of this less direct encoding is
--   that instances must be manually brought into scope using
--   <a>overEffs</a> and visible type application.
class OverEffs c ts m
overEffs :: OverEffs c ts m => (c (EffsT ts m) => r) -> r

-- | An <b>internal</b> helper class used to implement <a>MonadTrans</a>
--   and <a>MonadTransControl</a> instances for <a>HandlerT</a>. This
--   allows us to avoid making <a>HandlerT</a> a data family by using
--   <a>inductHandler</a> to perform induction over the type-level list of
--   handlers. (We want to avoid making <a>HandlerT</a>) a data family so
--   that the interface is simpler, as it allows <a>runHandlerT</a> to
--   return an ordinary stack of <a>EffT</a> transformers.
class InductHandler c tag ts
inductHandler :: InductHandler c tag ts => (ts ~ '[] => r) -> (forall t ts'. (ts ~ (t : ts'), c t, c (HandlerT tag ts'), forall m. Monad m => OverEffs Monad ts' m) => Proxy ts -> r) -> r

-- | A helper for defining effect handlers in terms of other, existing
--   handlers. <tt>(<a>HandlerT</a> tag ts)</tt> is equivalent to
--   <tt>(<a>EffsT</a> ts)</tt>, but the phantom <tt>tag</tt> parameter is
--   useful as a way to disambiguate between different handler instances.
newtype HandlerT tag ts m a
HandlerT :: EffsT ts m a -> HandlerT tag ts m a
[runHandlerT] :: HandlerT tag ts m a -> EffsT ts m a
type family StEffsT ts a

-- | An open type family that is used to determine which effects ought to
--   be handled by which handlers. If <tt><a>Handles</a> t eff</tt> ~
--   '<a>True</a> for some handler <tt>t</tt> and effect <tt>eff</tt>, the
--   handler will be used to handle any effects sent to it via <a>send</a>;
--   otherwise, the effect will be lifted to the next handler in the stack.
--   
--   It is important that <tt><a>Handles</a> t</tt> is total in its
--   argument; that is, it is important that effects that <i>cannot</i> be
--   handled produce <tt>'<a>False</a></tt>, not just that effects that can
--   be handled produce <tt>'<a>True</a></tt>. The <a>==</a> type family is
--   provided for this purpose: If a handler only handles a single effect,
--   its <a>Handles</a> instance should look like the following:
--   
--   <pre>
--   type <a>Handles</a> MyEffectT eff = eff <a>==</a> MyEffect
--   </pre>
--   
--   If it handles multiple effects, it can use the <a>Elem</a> type family
--   instead:
--   
--   <pre>
--   type <a>Handles</a> MyEffectT eff = eff `<a>Elem</a>` '[MyEffect1, MyEffect2]
--   </pre>
--   
--   More complex <a>Handles</a> instances are possible, but not generally
--   very useful.
type family Handles (t :: HandlerK) (eff :: EffectK) :: Bool

-- | Checks if <tt>x</tt> is in the type-level list <tt>xs</tt> (like
--   <a>elem</a>, but at the type level).
type family Elem (x :: k) (xs :: [k]) :: Bool
class Handle (handles :: Bool) eff t m
handle :: Handle handles eff t m => (eff (t m) => t m a) -> ((MonadTransControl t, eff m) => t m a) -> EffT t m a

-- | A typeclass used to lift effectful actions into effect handlers. This
--   is not necessary to use directly when using effects, but it is used as
--   part of defining new effects. Every effect should be given an instance
--   on <a>EffT</a> of the shape
--   
--   <pre>
--   instance <a>Send</a> <i>eff</i> t m =&gt; <i>eff</i> (<a>EffT</a> t m) where
--   </pre>
--   
--   where <tt><i>eff</i></tt> is replaced by the actual effect in
--   question. Each method should be implemented using <a>send</a> or
--   <a>sendWith</a>: <a>send</a> for algebraic/first-order operations and
--   <a>sendWith</a> for scoped/higher-order ones.
--   
--   There is no need to define any additional instances of this class.
class (Monad m, Handle (Handles t eff) eff t m) => Send eff t m

-- | Constructs an <tt><a>EffT</a> t m a</tt> computation for an
--   algebraic/first-order operation. Each first-order method in the
--   <a>EffT</a> instance for a given effect should have the shape
--   
--   <pre>
--   <i>method</i> <i>a</i> <i>b</i> <i>c</i> = <a>send</a> @<i>eff</i> (<i>method</i> <i>a</i> <i>b</i> <i>c</i>)
--   </pre>
--   
--   where <tt><i>method</i> <i>a</i> <i>b</i> <i>c</i></tt> should be
--   replaced with the method and its arguments, and <tt><i>eff</i></tt>
--   should be replaced with the type of the effect. The explicit type
--   application is necessary because <tt>eff</tt> only appears in a
--   constraint in the type signature for <a>send</a>, which GHC cannot
--   automatically infer.
--   
--   <tt><a>send</a> @<i>eff</i> <i>m</i></tt> is equivalent to
--   <tt><a>sendWith</a> @<i>eff</i> <i>m</i> (<a>lift</a> <i>m</i>)</tt>.
send :: Send eff t m => (forall n. eff n => n a) -> EffT t m a

-- | Constructs an <tt><a>EffT</a> t m a</tt> computation for a
--   higher-order/scoped effect <tt>eff</tt> from two actions:
--   
--   <ol>
--   <li>A “run” action, which executes the effect in the <tt>(t m)</tt>
--   monad given <tt>(t m)</tt> has an instance of <tt>eff</tt>.</li>
--   <li>A “lift” action, which lifts the effect through <tt>(t m)</tt>
--   into <tt>m</tt> given that <tt>t</tt> has a <a>MonadTransControl</a>
--   instance and <tt>m</tt> has an instance of <tt>eff</tt>.</li>
--   </ol>
--   
--   Each higher-order method in the <a>EffT</a> instance for a given
--   effect should use <a>sendWith</a> to specify how it ought to be lifted
--   through effect handlers. For example, the definition of <a>local</a>
--   looks like this:
--   
--   <pre>
--   <a>local</a> f m = <a>sendWith</a> @(<a>Reader</a> r)
--     (<a>local</a> f (<a>runEffT</a> m))
--     (<a>controlT</a> <a>$</a> \lower -&gt; <a>local</a> f (lower <a>$</a> <a>runEffT</a> m))
--   </pre>
--   
--   With this instance in place, <tt><a>Reader</a> r</tt> can
--   automatically be used with <tt><a>EffT</a> t m a</tt>. Transformers
--   that can handle the <tt><a>Reader</a> r</tt> effect (i.e. ones for
--   which <tt><a>Handles</a> t (<a>Reader</a> r) ~ '<a>True</a></tt>) will
--   use their <tt><a>Reader</a> r</tt> instances, while other transformers
--   will delegate to the underlying monad.
sendWith :: Send eff t m => (eff (t m) => t m a) -> ((MonadTransControl t, eff m) => t m a) -> EffT t m a

-- | Using <a>MonadTransControl</a>, lifts a higher-order effectful
--   operation into the underlying monad. It is named by analogy to
--   <a>control</a>, since both are intended for lifting “control
--   operations,” i.e. operations that affect control flow.
--   
--   <tt><a>controlT</a> f</tt> is equivalent to <tt><a>restoreT</a>
--   <a>.</a> <a>pure</a> =&lt;&lt; <a>liftWith</a> f</tt>, but it is rare
--   that <a>restoreT</a> or <a>liftWith</a> need to be used directly.
controlT :: (MonadTransControl t, Monad m, Monad (t m)) => (Run t -> m (StT t a)) -> t m a
type family All (cs :: [k -> Constraint]) (a :: k) :: Constraint

-- | A helper type for combining effect constraints: <tt>(<a>Can</a> '[e1,
--   e2, e3, ..., en] m)</tt> is equivalent to <tt>(e1 m, e2 m, e3 m, ...,
--   en m)</tt>. The constraint <tt><a>Can</a> effs m</tt> should be read
--   as specifying that the monad <tt>m</tt> <i>can</i> perform all of the
--   effects in the list <tt>effs</tt>.
class All effs m => Can (effs :: [EffectK]) m
instance Control.Monad.Trans.Control.MonadTransControl t => Control.Monad.Trans.Control.MonadTransControl (Control.Effect.Internal.EffT t)
instance Control.Monad.Trans.Class.MonadTrans t => Control.Monad.Trans.Class.MonadTrans (Control.Effect.Internal.EffT t)
instance GHC.Base.Monad (t m) => GHC.Base.Monad (Control.Effect.Internal.EffT t m)
instance GHC.Base.Applicative (t m) => GHC.Base.Applicative (Control.Effect.Internal.EffT t m)
instance GHC.Base.Functor (t m) => GHC.Base.Functor (Control.Effect.Internal.EffT t m)
instance forall k (ts :: [Control.Effect.Internal.HandlerK]) (m :: * -> *) (tag :: k). GHC.Base.Functor (Control.Effect.Internal.EffsT ts m) => GHC.Base.Functor (Control.Effect.Internal.HandlerT tag ts m)
instance forall k (ts :: [Control.Effect.Internal.HandlerK]) (m :: * -> *) (tag :: k). GHC.Base.Applicative (Control.Effect.Internal.EffsT ts m) => GHC.Base.Applicative (Control.Effect.Internal.HandlerT tag ts m)
instance forall k (ts :: [Control.Effect.Internal.HandlerK]) (m :: * -> *) (tag :: k). GHC.Base.Alternative (Control.Effect.Internal.EffsT ts m) => GHC.Base.Alternative (Control.Effect.Internal.HandlerT tag ts m)
instance forall k (ts :: [Control.Effect.Internal.HandlerK]) (m :: * -> *) (tag :: k). GHC.Base.Monad (Control.Effect.Internal.EffsT ts m) => GHC.Base.Monad (Control.Effect.Internal.HandlerT tag ts m)
instance forall k (ts :: [Control.Effect.Internal.HandlerK]) (m :: * -> *) (tag :: k). GHC.Base.MonadPlus (Control.Effect.Internal.EffsT ts m) => GHC.Base.MonadPlus (Control.Effect.Internal.HandlerT tag ts m)
instance forall k (ts :: [Control.Effect.Internal.HandlerK]) (m :: * -> *) (tag :: k). Control.Monad.IO.Class.MonadIO (Control.Effect.Internal.EffsT ts m) => Control.Monad.IO.Class.MonadIO (Control.Effect.Internal.HandlerT tag ts m)
instance forall k (b :: * -> *) (ts :: [Control.Effect.Internal.HandlerK]) (m :: * -> *) (tag :: k). (GHC.Base.Monad b, Control.Monad.Base.MonadBase b (Control.Effect.Internal.EffsT ts m)) => Control.Monad.Base.MonadBase b (Control.Effect.Internal.HandlerT tag ts m)
instance forall k (b :: * -> *) (ts :: [Control.Effect.Internal.HandlerK]) (m :: * -> *) (tag :: k). (GHC.Base.Monad b, Control.Monad.Trans.Control.MonadBaseControl b (Control.Effect.Internal.EffsT ts m)) => Control.Monad.Trans.Control.MonadBaseControl b (Control.Effect.Internal.HandlerT tag ts m)
instance Control.Effect.Internal.All effs m => Control.Effect.Internal.Can effs m
instance (Control.Effect.Internal.Send GHC.Base.Alternative t m, GHC.Base.Monad (t m)) => GHC.Base.Alternative (Control.Effect.Internal.EffT t m)
instance (Control.Effect.Internal.Send GHC.Base.Alternative t m, GHC.Base.Monad (t m)) => GHC.Base.MonadPlus (Control.Effect.Internal.EffT t m)
instance (GHC.Base.Monad m, Control.Effect.Internal.Handle (Control.Effect.Internal.Handles t eff) eff t m) => Control.Effect.Internal.Send eff t m
instance eff (t m) => Control.Effect.Internal.Handle 'GHC.Types.True eff t m
instance (Control.Monad.Trans.Control.MonadTransControl t, eff m) => Control.Effect.Internal.Handle 'GHC.Types.False eff t m
instance forall k (tag :: k) (ts :: [Control.Effect.Internal.HandlerK]). (Control.Monad.Trans.Class.MonadTrans (Control.Effect.Internal.HandlerT tag ts), Control.Effect.Internal.InductHandler Control.Monad.Trans.Control.MonadTransControl tag ts) => Control.Monad.Trans.Control.MonadTransControl (Control.Effect.Internal.HandlerT tag ts)
instance forall k (c :: ((* -> *) -> * -> *) -> GHC.Types.Constraint) (tag :: k) (ts :: [Control.Effect.Internal.HandlerK]). c (Control.Effect.Internal.HandlerT tag ts) => Control.Effect.Internal.InductHandler c tag '[]
instance forall k (ts :: [Control.Effect.Internal.HandlerK]) (c :: ((* -> *) -> * -> *) -> GHC.Types.Constraint) (t :: (* -> *) -> * -> *) (tag :: k). (forall (m :: * -> *). GHC.Base.Monad m => Control.Effect.Internal.OverEffs GHC.Base.Monad ts m, c t, c (Control.Effect.Internal.HandlerT tag ts)) => Control.Effect.Internal.InductHandler c tag (t : ts)
instance forall k (tag :: k) (ts :: [Control.Effect.Internal.HandlerK]). Control.Effect.Internal.InductHandler Control.Monad.Trans.Class.MonadTrans tag ts => Control.Monad.Trans.Class.MonadTrans (Control.Effect.Internal.HandlerT tag ts)
instance c (Control.Effect.Internal.EffsT ts m) => Control.Effect.Internal.OverEffs c ts m
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.Trans.Class.MonadTrans t, GHC.Base.Monad (t m)) => Control.Monad.IO.Class.MonadIO (Control.Effect.Internal.EffT t m)
instance (Control.Monad.Base.MonadBase b m, Control.Monad.Trans.Class.MonadTrans t, GHC.Base.Monad (t m)) => Control.Monad.Base.MonadBase b (Control.Effect.Internal.EffT t m)
instance (Control.Monad.Trans.Control.MonadBaseControl b m, Control.Monad.Trans.Control.MonadTransControl t, GHC.Base.Monad (t m)) => Control.Monad.Trans.Control.MonadBaseControl b (Control.Effect.Internal.EffT t m)

module Control.Effect.Reader

-- | <tt><a>Reader</a> r</tt> is an effect that provides access to a global
--   environment of type <tt>r</tt>.
--   
--   Instances should obey the law <tt>f <a>&lt;$&gt;</a> <a>ask</a></tt> ≡
--   <tt><a>asks</a> f</tt> ≡ <tt><a>local</a> f <a>ask</a></tt>.
class Monad m => Reader r m

-- | Retrieves a value from the environment.
ask :: Reader r m => m r

-- | Applies a function to a value in the environment and returns the
--   result.
asks :: Reader r m => (r -> a) -> m a

-- | Runs a subcomputation in an environment modified by the given
--   function.
local :: Reader r m => (r -> r) -> m a -> m a

-- | Handles a <tt><a>Reader</a> r</tt> effect by supplying a value for the
--   environment.
runReader :: r -> EffT (ReaderT r) m a -> m a

-- | The reader monad transformer, which adds a read-only environment to
--   the given monad.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
data ReaderT r (m :: Type -> Type) a
instance (GHC.Base.Monad (t m), Control.Effect.Internal.Send (Control.Effect.Reader.Reader r) t m) => Control.Effect.Reader.Reader r (Control.Effect.Internal.EffT t m)
instance GHC.Base.Monad m => Control.Effect.Reader.Reader r (Control.Monad.Trans.Reader.ReaderT r m)

module Control.Effect.Error

-- | <tt><a>Error</a> e</tt> is an effect that allows throwing and catching
--   errors of type <tt>e</tt>. Note that these have no relation to
--   Haskell’s built-in support for synchronous or asynchronous runtime
--   exceptions provided from <a>Control.Exception</a>.
--   
--   Instances should obey the law <tt><a>catch</a> (<a>throw</a> x) f</tt>
--   ≡ <tt><a>pure</a> (f x)</tt>.
class Monad m => Error e m

-- | Raises an error of type <tt>e</tt>.
throw :: Error e m => e -> m a

-- | Runs the given sub-computation. If it raises an error of type
--   <tt>e</tt>, the error is provided to the given handler function, and
--   execution resumes from the point of the call to <a>catch</a>.
catch :: Error e m => m a -> (e -> m a) -> m a

-- | Handles an <tt><a>Error</a> e</tt> effect. Returns <a>Left</a> if the
--   computation raised an uncaught error, otherwise returns <a>Right</a>.
runError :: EffT (ExceptT e) m a -> m (Either e a)

-- | A monad transformer that adds exceptions to other monads.
--   
--   <tt>ExceptT</tt> constructs a monad parameterized over two things:
--   
--   <ul>
--   <li>e - The exception type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a computation that produces the
--   given value, while <tt>&gt;&gt;=</tt> sequences two subcomputations,
--   exiting on the first exception.
data ExceptT e (m :: Type -> Type) a
instance (GHC.Base.Monad (t m), Control.Effect.Internal.Send (Control.Effect.Error.Error e) t m) => Control.Effect.Error.Error e (Control.Effect.Internal.EffT t m)
instance GHC.Base.Monad m => Control.Effect.Error.Error e (Control.Monad.Trans.Except.ExceptT e m)

module Control.Effect.State

-- | <tt><a>State</a> s</tt> is an effect that provides access to a single
--   cell of mutable state of type <tt>s</tt>.
class Monad m => State s m

-- | Retrieves the current value of the state.
get :: State s m => m s

-- | Replaces the current state with the given value.
put :: State s m => s -> m ()

-- | Modifies the current state by applying the given function to it.
modify :: State s m => (s -> s) -> m ()
runState :: Functor m => s -> EffT (StateT s) m a -> m (s, a)
evalState :: Monad m => s -> EffT (StateT s) m a -> m a
execState :: Monad m => s -> EffT (StateT s) m a -> m s

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
data StateT s (m :: Type -> Type) a
instance (GHC.Base.Monad (t m), Control.Effect.Internal.Send (Control.Effect.State.State s) t m) => Control.Effect.State.State s (Control.Effect.Internal.EffT t m)
instance GHC.Base.Monad m => Control.Effect.State.State s (Control.Monad.Trans.State.Strict.StateT s m)


-- | This library is an implementation of an <i>extensible effect
--   system</i> for Haskell, a general-purpose solution for tracking
--   effects at the type level and handling them in various ways. The term
--   “effect” as used by this library is very general: it encompasses
--   things most people consider side-effects, such as generating random
--   values, interacting with the file system, or mutating state, but it
--   also includes globally-pure but locally-impure operations such as
--   access to an immutable global environment or exception handling.
--   
--   The traditional approach to effect composition in Haskell is <i>monad
--   transformers</i>, but programming against a concrete stack of monad
--   transformers can make reuse difficult and tethers a program to a
--   particular implementation of each effect. The <tt>mtl</tt> library
--   provides a partial solution to this problem by providing a typeclass
--   for each effect, which allow programmers to parameterize computations
--   over the monad they are executed in. However, that technique has
--   problems of its own, most notably that it requires <i>m</i>×<i>n</i>
--   instances be written for code that uses <i>m</i> distinct effects and
--   <i>n</i> distinct effect implementations.
--   
--   <tt>eff</tt> is a reformulation of <tt>mtl</tt> that avoids the
--   “quadratic instance” problem. Like <tt>mtl</tt>, it uses monad
--   transformers to represent effect implementations, which <tt>eff</tt>
--   calls effect <i>handlers</i>, and it uses typeclasses to represent
--   effects. Unlike <tt>mtl</tt>, <tt>eff</tt> uses a slightly different
--   encoding that allows explicit instances to be written <i>only</i> for
--   the effects handled by each transformer, requiring a linear rather
--   than quadratic number of instances. It achieves this without any use
--   of overlapping instances or Template Haskell by keeping track of a
--   little extra information at the type level that can be used to guide
--   instance selection.
--   
--   Generally speaking, this library provides two discrete (but related)
--   chunks of functionality:
--   
--   <ol>
--   <li>First, <tt>eff</tt> provides a library of common effects, such as
--   <a>Reader</a>, <a>Error</a>, and <a>State</a>, as well as handlers for
--   them. These can be used out of the box the same way
--   <tt>transformers</tt> and <tt>mtl</tt> can be, and they use a similar
--   interface.</li>
--   <li>Second, <tt>eff</tt> exposes the infrastructure necessary to
--   define <i>your own</i> effects and effect handlers, all of which
--   automatically cooperate with the built-in effects and any effects
--   defined in other libraries.</li>
--   </ol>
--   
--   Compared to other Haskell effect system libraries, such as
--   <tt>freer</tt>, <tt>polysemy</tt>, and <tt>fused-effects</tt>,
--   <tt>eff</tt> distinguishes itself in the following respects:
--   
--   <ul>
--   <li><tt>eff</tt> is, at the time of this writing, the fastest effect
--   system available. Its performance is equivalent to that of
--   <tt>mtl</tt>, which is slightly faster than <tt>fused-effects</tt> and
--   significantly faster than <tt>freer</tt> or <tt>polysemy</tt> on real
--   workloads. It is designed specifically to take advantage of the GHC
--   optimizer by cooperating with specialization as much as possible.</li>
--   <li><tt>eff</tt> integrates well with the existing
--   <tt>transformers</tt> ecosystem. Effect handlers in <tt>eff</tt> are
--   ordinary monad transformers, and many built-in effects are handled by
--   the ordinary transformers from the <tt>transformers</tt> package. As
--   in <tt>fused-effects</tt>, existing transformers can be easily adapted
--   into effect handlers, but <tt>eff</tt> goes a step further by allowing
--   existing <tt>mtl</tt>-style typeclasses to be used as effects, just by
--   defining a couple small instances.</li>
--   <li>Despite its use of monad transformers and its focus on
--   performance, defining effects and effect handlers in <tt>eff</tt>
--   requires relatively little boilerplate, though <tt>freer-simple</tt>
--   and <tt>polysemy</tt> provide some Template Haskell code that can
--   generate most of the boilerplate automatically. Providing similar
--   Template Haskell functionality is a future goal of this library, but
--   it as not yet been implemented.</li>
--   <li>Unlike <tt>freer</tt>, but like <tt>polysemy</tt> and
--   <tt>fused-effects</tt>, <tt>eff</tt> supports higher-order (or scoped)
--   effects, in addition to the more traditional algebraic effects.</li>
--   </ul>
module Control.Effect

-- | A helper type for combining effect constraints: <tt>(<a>Can</a> '[e1,
--   e2, e3, ..., en] m)</tt> is equivalent to <tt>(e1 m, e2 m, e3 m, ...,
--   en m)</tt>. The constraint <tt><a>Can</a> effs m</tt> should be read
--   as specifying that the monad <tt>m</tt> <i>can</i> perform all of the
--   effects in the list <tt>effs</tt>.
class All effs m => Can (effs :: [EffectK]) m

-- | The kind of effects, which are classes of monads.
type EffectK = (Type -> Type) -> Constraint

-- | A typeclass used to lift effectful actions into effect handlers. This
--   is not necessary to use directly when using effects, but it is used as
--   part of defining new effects. Every effect should be given an instance
--   on <a>EffT</a> of the shape
--   
--   <pre>
--   instance <a>Send</a> <i>eff</i> t m =&gt; <i>eff</i> (<a>EffT</a> t m) where
--   </pre>
--   
--   where <tt><i>eff</i></tt> is replaced by the actual effect in
--   question. Each method should be implemented using <a>send</a> or
--   <a>sendWith</a>: <a>send</a> for algebraic/first-order operations and
--   <a>sendWith</a> for scoped/higher-order ones.
--   
--   There is no need to define any additional instances of this class.
class (Monad m, Handle (Handles t eff) eff t m) => Send eff t m

-- | Constructs an <tt><a>EffT</a> t m a</tt> computation for an
--   algebraic/first-order operation. Each first-order method in the
--   <a>EffT</a> instance for a given effect should have the shape
--   
--   <pre>
--   <i>method</i> <i>a</i> <i>b</i> <i>c</i> = <a>send</a> @<i>eff</i> (<i>method</i> <i>a</i> <i>b</i> <i>c</i>)
--   </pre>
--   
--   where <tt><i>method</i> <i>a</i> <i>b</i> <i>c</i></tt> should be
--   replaced with the method and its arguments, and <tt><i>eff</i></tt>
--   should be replaced with the type of the effect. The explicit type
--   application is necessary because <tt>eff</tt> only appears in a
--   constraint in the type signature for <a>send</a>, which GHC cannot
--   automatically infer.
--   
--   <tt><a>send</a> @<i>eff</i> <i>m</i></tt> is equivalent to
--   <tt><a>sendWith</a> @<i>eff</i> <i>m</i> (<a>lift</a> <i>m</i>)</tt>.
send :: Send eff t m => (forall n. eff n => n a) -> EffT t m a

-- | Constructs an <tt><a>EffT</a> t m a</tt> computation for a
--   higher-order/scoped effect <tt>eff</tt> from two actions:
--   
--   <ol>
--   <li>A “run” action, which executes the effect in the <tt>(t m)</tt>
--   monad given <tt>(t m)</tt> has an instance of <tt>eff</tt>.</li>
--   <li>A “lift” action, which lifts the effect through <tt>(t m)</tt>
--   into <tt>m</tt> given that <tt>t</tt> has a <a>MonadTransControl</a>
--   instance and <tt>m</tt> has an instance of <tt>eff</tt>.</li>
--   </ol>
--   
--   Each higher-order method in the <a>EffT</a> instance for a given
--   effect should use <a>sendWith</a> to specify how it ought to be lifted
--   through effect handlers. For example, the definition of <a>local</a>
--   looks like this:
--   
--   <pre>
--   <a>local</a> f m = <a>sendWith</a> @(<a>Reader</a> r)
--     (<a>local</a> f (<a>runEffT</a> m))
--     (<a>controlT</a> <a>$</a> \lower -&gt; <a>local</a> f (lower <a>$</a> <a>runEffT</a> m))
--   </pre>
--   
--   With this instance in place, <tt><a>Reader</a> r</tt> can
--   automatically be used with <tt><a>EffT</a> t m a</tt>. Transformers
--   that can handle the <tt><a>Reader</a> r</tt> effect (i.e. ones for
--   which <tt><a>Handles</a> t (<a>Reader</a> r) ~ '<a>True</a></tt>) will
--   use their <tt><a>Reader</a> r</tt> instances, while other transformers
--   will delegate to the underlying monad.
sendWith :: Send eff t m => (eff (t m) => t m a) -> ((MonadTransControl t, eff m) => t m a) -> EffT t m a

-- | Using <a>MonadTransControl</a>, lifts a higher-order effectful
--   operation into the underlying monad. It is named by analogy to
--   <a>control</a>, since both are intended for lifting “control
--   operations,” i.e. operations that affect control flow.
--   
--   <tt><a>controlT</a> f</tt> is equivalent to <tt><a>restoreT</a>
--   <a>.</a> <a>pure</a> =&lt;&lt; <a>liftWith</a> f</tt>, but it is rare
--   that <a>restoreT</a> or <a>liftWith</a> need to be used directly.
controlT :: (MonadTransControl t, Monad m, Monad (t m)) => (Run t -> m (StT t a)) -> t m a

-- | The kind of effect handlers, which are monad transformers.
type HandlerK = (Type -> Type) -> Type -> Type

-- | A monad transformer for handling effects. <tt>(<a>EffT</a> t)</tt> is
--   actually no different from <tt>t</tt> at runtime, but it provides a
--   different set of instances. Wrapping a monad transformer with
--   <a>EffT</a> allows other effects to be automatically lifted through
--   it, provided the underlying transformer provides a
--   <a>MonadTransControl</a> instance.
--   
--   <a>EffT</a> cannot be used with any arbitrary monad transformer: all
--   monad transformers wrapped with <a>EffT</a> <i>must</i> provide an
--   instance of the <a>Handles</a> type family to cooperate with effect
--   with the effect lifting machinery. However, note that this requirement
--   only applies to transformers wrapped in <a>EffT</a> directly, i.e.
--   used as the <tt>t</tt> argument in <tt>(<a>EffT</a> t)</tt>; there are
--   no restrictions placed on the underlying monad (though effects will
--   not be able to be automatically lifted through non-<a>EffT</a>
--   layers).
newtype EffT (t :: HandlerK) m a
EffT :: t m a -> EffT (t :: HandlerK) m a
[runEffT] :: EffT (t :: HandlerK) m a -> t m a

-- | A type alias for a stack of nested <a>EffT</a> transformers:
--   <tt><a>EffsT</a> '[t1, t2, ..., tn] m</tt> is equivalent to
--   <tt><a>EffT</a> t1 (<a>EffT</a> t2 (... (<a>EffT</a> tn m) ...))</tt>.
--   
--   This can be considered the implementation dual to the <a>Can</a>
--   interface.
type family EffsT ts m

-- | An open type family that is used to determine which effects ought to
--   be handled by which handlers. If <tt><a>Handles</a> t eff</tt> ~
--   '<a>True</a> for some handler <tt>t</tt> and effect <tt>eff</tt>, the
--   handler will be used to handle any effects sent to it via <a>send</a>;
--   otherwise, the effect will be lifted to the next handler in the stack.
--   
--   It is important that <tt><a>Handles</a> t</tt> is total in its
--   argument; that is, it is important that effects that <i>cannot</i> be
--   handled produce <tt>'<a>False</a></tt>, not just that effects that can
--   be handled produce <tt>'<a>True</a></tt>. The <a>==</a> type family is
--   provided for this purpose: If a handler only handles a single effect,
--   its <a>Handles</a> instance should look like the following:
--   
--   <pre>
--   type <a>Handles</a> MyEffectT eff = eff <a>==</a> MyEffect
--   </pre>
--   
--   If it handles multiple effects, it can use the <a>Elem</a> type family
--   instead:
--   
--   <pre>
--   type <a>Handles</a> MyEffectT eff = eff `<a>Elem</a>` '[MyEffect1, MyEffect2]
--   </pre>
--   
--   More complex <a>Handles</a> instances are possible, but not generally
--   very useful.
type family Handles (t :: HandlerK) (eff :: EffectK) :: Bool

-- | A type family to compute Boolean equality.
type family (a :: k) == (b :: k) :: Bool
infix 4 ==

-- | Checks if <tt>x</tt> is in the type-level list <tt>xs</tt> (like
--   <a>elem</a>, but at the type level).
type family Elem (x :: k) (xs :: [k]) :: Bool

-- | A helper for defining effect handlers in terms of other, existing
--   handlers. <tt>(<a>HandlerT</a> tag ts)</tt> is equivalent to
--   <tt>(<a>EffsT</a> ts)</tt>, but the phantom <tt>tag</tt> parameter is
--   useful as a way to disambiguate between different handler instances.
newtype HandlerT tag ts m a
HandlerT :: EffsT ts m a -> HandlerT tag ts m a
[runHandlerT] :: HandlerT tag ts m a -> EffsT ts m a
